# Copyright Â© VASP Software GmbH,
# Licensed under the Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
from __future__ import annotations

import dataclasses
import pathlib
from datetime import datetime
from typing import Any, Iterable, Optional, Union

from py4vasp._raw import mapping
from py4vasp._raw.data_wrapper import VaspData


def NONE():
    return dataclasses.field(default_factory=lambda: VaspData(None))


@dataclasses.dataclass(order=True, frozen=True)
class Version:
    "The version number of VASP."

    major: int
    "The major version number."
    minor: int = 0
    "The minor version number."
    patch: int = 0
    "Indicates number of bugfixes since last minor release."
    __str__ = lambda self: f"version {self.major}.{self.minor}.{self.patch}"


@dataclasses.dataclass
class Band:
    """A band structure generated by VASP.

    Contains the eigenvalues at specifics **k** points in the Brillouin zone. Carefully
    consider before using the absolute eigenvalues for analysis. Typically only relative
    eigenvalues e.g. with respect to the Fermi energy are meaningful. Includes
    projections of the bands on orbitals and atoms when available."""

    dispersion: Dispersion
    "The **k** points and eigenvalues of the dispersion."
    fermi_energy: float
    "Fermi energy obtained by VASP."
    occupations: VaspData
    "The occupations of the different bands."
    projectors: Projector
    "Projector information (element, angular momentum, spin)."
    projections: VaspData = NONE()
    "If present, orbital projections of the bands."


@dataclasses.dataclass
class Bandgap:
    """The bandgap of the system.

    Contains the band extrema defining the fundamental and optical band gap and the
    k-point coordinates where the band gaps are for all steps of a relaxation/MD
    simulation."""

    labels: VaspData
    "These labels identify which band data is stored."
    values: VaspData
    "The data contained according to the labels."


@dataclasses.dataclass
class BornEffectiveCharge:
    """The Born effective charges resulting form a linear response calculation.

    The Born effective charges describe how the polarization of a system changes with
    the position of the ions. Equivalently, an electric field induces forces on the
    ions. In general, the Born effective charges are matrices, i.e., the polarization
    and the displacement of the ion are not necessarily parallel."""

    structure: Structure
    "Structural information about the system to identify specific atoms."
    charge_tensors: VaspData
    "The data of the Born effective charges."


@dataclasses.dataclass
class Cell:
    """Unit cell of the crystal or simulation cell for molecules.

    In MD simulations or relaxations, VASP exports the unit cell for every step,
    because it may change depending on the ISIF setting."""

    lattice_vectors: VaspData
    "Lattice vectors defining the unit cell."
    scale: float
    "Global scaling factor applied to all lattice vectors."


@dataclasses.dataclass
class CONTCAR:
    """The data corresponding to the CONTCAR file.

    The CONTCAR file contains structural information (lattice, positions, stoichiometry),
    relaxation constraints, and data relevant for continuation calculations.
    """

    structure: Structure
    "The structure of the system at the end of the calculation."
    system: str
    "A comment line describing the system."
    selective_dynamics: VaspData = NONE()
    "Specifies in which directions the atoms may move."
    lattice_velocities: VaspData = NONE()
    "The current velocities of the lattice vectors."
    ion_velocities: VaspData = NONE()
    "The current velocities of the ions in Cartesian coordinates."
    _predictor_corrector: VaspData = NONE()
    "Internal algorithmic data relevant for restarting calculations."


@dataclasses.dataclass
class CurrentDensity(mapping.Mapping):
    """The current density evaluated on a grid in the unit cell.

    You may have multiple currents densities which you can set by the *valid_indices*
    variable. The current_density list should have the same size as the valid_indices.
    """

    structure: Structure
    "The structure for which the current density was calculated."
    current_density: VaspData
    "The current density on a grid in the unit cell."


@dataclasses.dataclass
class CalculationMetaData:
    """Metadata about the VASP calculation.
    This dataclass is not available for Calculation instances."""

    hdf5_original_path: Union[str, pathlib.Path]
    """The path to the HDF5 file of the original calculation."""
    tags: Union[str, Iterable[str], None]
    """Tags associated with the calculation."""

    hdf5_internal_path: Optional[Union[str, pathlib.Path]] = None
    """The path under which vaspdb has stored the calculation files."""

    infer_none_files: bool = False
    """Whether to infer links to None files like INCAR etc. where possible."""
    has_incar: bool = False
    "Whether an INCAR file is associated with the calculation."
    has_poscar: bool = False
    "Whether a POSCAR file is associated with the calculation."
    has_kpoints: bool = False
    "Whether a KPOINTS file is associated with the calculation."
    has_potcar: bool = False
    "Whether a POTCAR file is associated with the calculation."
    has_contcar: bool = False
    "Whether a CONTCAR file is associated with the calculation."
    has_outcar: bool = False
    "Whether an OUTCAR file is associated with the calculation."

    # These should be handled by vaspdb
    added_at: Optional[datetime] = None
    "The date and time when the calculation data was added to the database."
    updated_at: Optional[datetime] = None
    "The date and time when the calculation data was last updated in the database."

    def __post_init__(self):
        # Convert paths to pathlib Paths
        for file_attr in ["hdf5_original_path", "hdf5_internal_path"]:
            file_path = getattr(self, file_attr)
            if isinstance(file_path, str):
                object.__setattr__(self, file_attr, pathlib.Path(file_path))

        # Check existence of INCAR, POSCAR, KPOINTS, POTCAR files
        if self.infer_none_files:
            for file_attr in [
                "incar",
                "poscar",
                "kpoints",
                "potcar",
                "contcar",
                "outcar",
            ]:
                trial_path = self.hdf5_original_path.parent / file_attr.upper()
                if trial_path.exists():
                    setattr(self, f"has_{file_attr}", True)


@dataclasses.dataclass
class _DatabaseData:
    """All additional data that should be written to the database.
    This dataclass is not available for Calculation instances."""

    metadata: CalculationMetaData

    available_quantities: Optional[dict[str, tuple[bool, list[str]]]] = None
    """Dict of all py4vasp dataclasses that can be read from the HDF5 file.
    Keys are constructed like 'group.quantity:selection' where group and
    selection are optional. The values are booleans indicating whether the quantity is available.
    The string list contains all aliases that can be used to refer to this particular combination
    of group, quantity and selection."""

    additional_properties: Optional[dict[str, Any]] = None
    """Additional properties that get stored in the database.
    Keys are constructed like 'group.quantity:selection' where group and
    selection are optional. The values are dictionaries of properties."""


@dataclasses.dataclass
class Density:
    "The electronic charge and magnetization density on the Fourier grid."

    structure: Structure
    "The atomic structure to represent the densities."
    charge: VaspData
    "The data of electronic charge and magnetization density."


@dataclasses.dataclass
class DielectricFunction:
    """The full frequency-dependent dielectric function.

    The total dielectric function is the sum of the ionic and electronic part. It
    provides insight into optical properties such as the reflectivity and absorption.
    Note that the dielectric function is a 3x3 matrix for every frequency. There are
    many different levels of theory with which you can evaluate the dielectric function
    in VASP. For the electronic dielectric function a current-current response may be
    provided as alternative."""

    energies: VaspData
    "The energies at which the dielectric function is evaluated."
    dielectric_function: VaspData
    "The values of the dielectric function (frequency-dependent 3x3 tensor)."
    current_current: VaspData = NONE()
    "Dielectric function obtained using the current-current response."


@dataclasses.dataclass
class DielectricTensor:
    """The dielectric tensor resulting from ionic and electronic contributions.

    The dielectric tensor should match with the zero frequency limit of the dielectric
    function. The electronic contribution is also provided in the independent particle
    approximation."""

    electron: VaspData
    "The electronic contribution to the dielectric tensor."
    ion: VaspData
    "The ionic contribution to the dielectric tensor."
    independent_particle: VaspData
    "The dielectric tensor in the independent particle approximation."
    method: str
    "The method used to generate the dielectric tensor."


@dataclasses.dataclass
class Dispersion:
    """A general class for dispersions (electron and phonon)."""

    kpoints: Kpoint
    "**k** points at which the bands are calculated."
    eigenvalues: VaspData
    "Calculated eigenvalues at the **k** points."


@dataclasses.dataclass
class Dos:
    """Contains the density of states (DOS) including its projections where available.

    Contains the energy mesh and the values of the DOS at the mesh points. When LORBIT
    is set in the INCAR file, VASP projects the DOS onto atoms and orbitals. Typically,
    the absolute value of the energy mesh is not important and shifting the energies to
    a reference e.g. the Fermi energy is desired."""

    energies: VaspData
    "Energy E at which the Dos is evaluated."
    dos: VaspData
    "Dos at the energies D(E)."
    fermi_energy: float
    "Fermi energy obtained by VASP."
    projectors: Projector
    "Projector information (element, angular momentum, spin)."
    projections: VaspData = NONE()
    "If present, orbital projections of the Dos."


@dataclasses.dataclass
class EffectiveCoulomb:
    """The effective Coulomb potential calculated with a cRPA method.

    The effective Coulomb potential U is calculated in VASP using the constrained Random
    Phase Approximation (cRPA). This method allows to compute the screened Coulomb
    interaction by excluding specific screening channels, typically those within a
    correlated subspace such as d or f orbitals.
    """

    number_wannier_states: int
    "Number of Wannier functions used to define the correlated subspace."
    spin_labels: VaspData
    "Labels for the spin channels used in the calculation."
    frequencies: VaspData
    "Frequencies at which the effective Coulomb potential is evaluated."
    bare_potential_high_cutoff: VaspData
    "The bare Coulomb potential before screening evaluated with a high cutoff."
    bare_potential_low_cutoff: VaspData
    "The bare Coulomb potential before screening evaluated with a low cutoff."
    screened_potential: VaspData
    "The screened effective Coulomb potential U."
    cell: Cell
    "Unit cell of the crystal."
    positions: VaspData = NONE()
    "Positions in units of the lattice vectors where the effective Coulomb potential is evaluated."


@dataclasses.dataclass
class ElasticModulus:
    """The elastic modulus calculated in a linear response calculation.

    The elastic modulus is the second derivative of the total energy with respect to
    a strain in the system. When straining the system, one can enforce or relax the
    positions of the ions. Correspondingly, VASP evaluates the clamped-ion and
    relaxed-ion elastic modulus."""

    clamped_ion: VaspData
    "Elastic modulus when the ions are clamped into their positions."
    relaxed_ion: VaspData
    "Elastic modulus when the position of the ions is relaxed."


@dataclasses.dataclass
class ElectronicMinimization:
    """The OSZICAR data as generated by VASP.

    All data generated by VASP and traditionally stored in the OSZICAR file will be
    stored here. See https://www.vasp.at/wiki/index.php/OSZICAR for more details about
    what quantities to expect."""

    convergence_data: VaspData
    "All columns of the OSZICAR file stored for all ionic steps."
    label: VaspData
    "Label of all the data from the OSZICAR file."
    is_elmin_converged: VaspData
    "Is the electronic minimization step converged?"


@dataclasses.dataclass
class ElectronPhononBandgap(mapping.Mapping):
    """The bandgap renormalized due to electron-phonon coupling

    The information is derived from a self-energy calculation.
    """

    chemical_potential: ElectronPhononChemicalPotential
    "Chemical potential information"
    fundamental_renorm: VaspData
    "Renormalization of the fundamental bandgap"
    fundamental: VaspData
    "Value of the fundamental bandgap"
    direct_renorm: VaspData
    "Renormalization of the direct bandgap"
    direct: VaspData
    "Value of the direct bandgap"
    temperatures: VaspData
    "List of temperatures at which the bandgap renormalization was computed"
    nbands_sum: list[int]
    "Number of bands that were summed over in this instance"
    delta: list[float]
    "Value of the imaginary broadening parameter used to evaluate the electron self-energy"
    scattering_approximation: list[str]
    "Scattering approximation used to compute the electron self-energy"
    id_index: VaspData
    "Index of the elements on each list of variables used to generate instances"


@dataclasses.dataclass
class ElectronPhononChemicalPotential:
    """The chemical potential for electron-phonon calculations.

    The chemical potential is computed for each temperature and carrier doping.
    The carrier doping can be specified using only one of:
    carrier_per_cell, carrier_den or mu
    """

    fermi_energy: VaspData
    "The Fermi energy at zero temperature and without doping"
    chemical_potential: VaspData
    "The chemical potential for each temperature and doping"
    carrier_density: VaspData
    "Computed carrier density for each temperature and doping"
    temperatures: VaspData
    "List of temperatures at which the chemical potential is computed"
    carrier_per_cell: VaspData  # values of the selfen_carrier_per_cell incar tag
    "The doping specified by the additional number of carriers per cell"
    carrier_den: VaspData  # values of th selfen_carrier_den incar tag
    "The doping specified by an additional carrier density"
    mu: VaspData  # values of the selfen_mu incar tag
    "The doping specified by an energy shift with respect to the fermi energy"


@dataclasses.dataclass
class ElectronPhononSelfEnergy(mapping.Mapping):
    """The electron self-energy due to electron-phonon coupling

    This is composed of two Feynman diagrams, the Fan and Debye-Waller.
    They are compued only for selectes Kohn-Sham states and stored in a flattened array.
    When the scattering approximation is not SERTA then strictly speaking
    this is not a self-energy anymore but a scattering rate that is used in the
    context of solving the Boltzman transport equation (see ElectronPhononTransport)
    """

    id_index: VaspData
    "Index of the elements on each list of variables used to generate instances"
    chemical_potential: ElectronPhononChemicalPotential
    "Chemical potential information"
    eigenvalues: VaspData
    "Kohn-sham eigenvalues on the mesh used for the electron-phonon calculation"
    temperatures: VaspData
    "List of temperatures at which the self energy was computed"
    debye_waller: VaspData
    "Debye-Waller self-energy contribution as an array flattened along (band,kpoint,spin)"
    fan: VaspData
    "Fan self-energy contribution for an array of energies as an array flattened along (band,kpoint,spin)"
    energies: VaspData
    "Energies at which the Fan self-energy was evaluated."
    band_kpoint_spin_index: VaspData
    "Translate a (band,kpoint,spin) tuple to the flattened array"
    band_start: int
    "Index of the lowest band for which the electron self-energy was computed"
    nbands_sum: int
    "Number of bands that were summed over in this instance"
    delta: float
    "Value of the imaginary broadening parameter used to evaluate the electron self-energy"
    scattering_approximation: str
    "Scattering approximation used to compute the electron self-energy"


@dataclasses.dataclass
class ElectronPhononTransport(mapping.Mapping):
    """Electronic transport quantities limited by electron-phonon scattering

    The electronic transport coefficients are computed based on the electronic group-velocities
    and scattering rated computed the self-energy accumulators.
    They are computed for each temperature and chemical potential specified in the INCAR file
    """

    id_index: VaspData
    "Index of the elements on each list of variables used to generate instances"
    chemical_potential: ElectronPhononChemicalPotential
    "Chemical potential information"
    temperatures: VaspData
    "List of temperatures at which the bandgap renormalization was computed"
    transport_function: VaspData
    """Transport function which is computed from the electron group-velocities
    and scattering rated for each temperature and carrier doping
    """
    electronic_conductivity: VaspData
    "Electronic conductivity for each temperature and carrier doping"
    mobility: VaspData
    "Electronic mobility for each temperature and carrier doping"
    seebeck: VaspData
    "Seebeck coefficient for each temperature and carrier doping"
    peltier: VaspData
    "Peltier coefficient for each temperature and carrier doping"
    electronic_thermal_conductivity: VaspData
    "Electronic thermal conductivity for each temperature and carrier doping"
    nbands_sum: int
    "Number of bands that were summed over in this instance"
    delta: float
    "Value of the imaginary broadening parameter used to evaluate the electron self-energy"
    scattering_approximation: str
    "Scattering approximation used to compute the electron self-energy"


@dataclasses.dataclass
class Energy:
    """Various energies during ionic relaxation or MD simulation.

    At every step during a simulation, VASP stores the energy values. For MD simulations,
    VASP includes temperature information from the thermostat."""

    labels: VaspData
    "Label identifying which energy is contained."
    values: VaspData
    "Energy specified by labels for all iteration steps."


@dataclasses.dataclass
class ExcitonDensity:
    "The exciton charge density on the real space grid."

    structure: Structure
    "The atomic structure to represent the densities."
    exciton_charge: VaspData
    "The data of exciton charge density."


@dataclasses.dataclass
class ExcitonEigenvector:
    """Contains the BSE data required to produce a plot of eigenvector contributions."""

    dispersion: Dispersion
    "The **k** points and the eigenvalues of the band structure."
    fermi_energy: float
    "The Fermi energy of the system."
    bse_index: VaspData
    "The connection between spin, band and **k**-point indices to an index of the optical transitions."
    eigenvectors: VaspData
    "Component of the eigenvector, norm can be used for plotting eigenvectors."
    first_valence_band: int
    "Index of the first valence band."
    first_conduction_band: int
    "Index of the first conduction band."


@dataclasses.dataclass
class Force:
    """The forces acting on the atoms at all steps of a MD simulation or relaxation."""

    structure: Structure
    "Structural information about the system to inform about the forces."
    forces: VaspData
    "The values of the forces at the atoms."


@dataclasses.dataclass
class ForceConstant:
    """The force constants of the material.

    The force constant describes the second derivative of the total energy with respect
    to the displacement of ions. It is an important quantity for the phonon spectrum."""

    structure: Structure
    "Structural information about the system to inform about the atoms the force constants relate to."
    force_constants: VaspData
    "The values of the force constants."
    selective_dynamics: VaspData = NONE()
    "Specifies in which directions the atoms may move."


@dataclasses.dataclass
class InternalStrain:
    """The internal strain calculated in a linear response calculation.

    The internal strain describes which forces act on the ions when the crystal is
    subject to a strain. Equivalently, this determines the stress on the crystal
    induced from ionic displacements."""

    structure: Structure
    "Structural information about the system to inform about the unit cell."
    internal_strain: VaspData
    "The data of the internal strain."


@dataclasses.dataclass
class Kpoint:
    """A **k**-point mesh in the Brillouin zone.

    Describes how VASP generated the **k** points and contains their coordinates.
    Labels may be defined in the KPOINTS file and are then available for band structure
    plots. For integrations over the Brillouin zone, every **k** point exhibits an
    integration weight. Use the unit cell information to transform to Cartesian
    coordinates if desired."""

    mode: str
    "Mode used to generate the **k**-point list."
    number: int
    "Number of **k** points specified in the generation."
    coordinates: VaspData
    "Coordinates of the **k** points as fraction of the reciprocal lattice vectors."
    weights: VaspData
    "Weight of the **k** points used for integration."
    cell: Cell
    "Unit cell of the crystal."
    number_x: int = NONE()
    "The number of kpoints in x direction."
    number_y: int = NONE()
    "The number of kpoints in y direction."
    number_z: int = NONE()
    "The number of kpoints in z direction."
    labels: VaspData = NONE()
    "High symmetry label for specific **k** points used in band structures."
    label_indices: VaspData = NONE()
    "Indices of the labeled **k** points in the generation list."


@dataclasses.dataclass
class LocalMoment:
    """The local charges and magnetic moments on the ions.

    The projection on orbitals and atoms (LORBIT) distributes all bands over all ions
    according to the overlap with local projectors. This information reveals which
    ions and orbitals contribute to the magnetism in the system. VASP stores the
    projection for every step of a simulation so that one can monitor changes along
    a relaxation or MD run."""

    structure: Structure
    "Structural information about the system."
    spin_moments: VaspData
    "Contains the charge and magnetic moments atom and orbital resolved."
    orbital_moments: VaspData = NONE()
    "Contains the orbital magnetization for all atoms"


@dataclasses.dataclass
class Nics:
    """The nucleus-independent chemical shift."""

    structure: Structure
    "Structural information about the system."
    nics_grid: VaspData = NONE()
    "The NICS tensor (flattened) at every grid point."
    nics_points: VaspData = NONE()
    "The NICS tensor at specfic positions."
    positions: VaspData = NONE()
    "Positions at which NICS tensor was evaluated."


@dataclasses.dataclass
class PairCorrelation:
    """The pair-correlation function calculated during a MD simulation.

    The pair-correlation function describes how other ions are distributed around a
    given ion. VASP evaluates the total pair-function and the element-resolved ones."""

    distances: VaspData
    "The distances at which the pair-correlation function is evaluated."
    function: VaspData
    "The total and the element-resolved pair-correlation functions."
    labels: VaspData
    "Describes which indices correspond to which element pair."


@dataclasses.dataclass
class PartialDensity:
    """Electronic partial charge and magnetization density on the fine Fourier grid

    Possibly not only split by spin, but also by band and kpoint."""

    structure: Structure
    "The atomic structure to represent the densities."
    partial_charge: VaspData
    "The data of electronic charge and magnetization density."
    kpoints: VaspData
    "The kpoints at which the partial charge is evaluated."
    bands: VaspData
    "The bands at which the partial charge is evaluated."
    grid: VaspData
    "The fine FFT grid at which the partial charge is evaluated."


@dataclasses.dataclass
class PhononBand:
    """The band structure of the phonons.

    Contains the eigenvalues and eigenvectors at specifics **q** points in the Brillouin
    zone. Includes the stoichiometry to map atoms onto specific modes."""

    dispersion: Dispersion
    "The **q** points and the eigenvalues."
    stoichiometry: Stoichiometry
    "The atom types in the crystal."
    eigenvectors: VaspData
    "The eigenvectors of the phonon modes."


@dataclasses.dataclass
class PhononDos:
    """Contains the phonon density of states (DOS) including its projections where available.

    Contains the energy mesh and the values of the DOS at the mesh points. The DOS can be
    projected onto specific ions or ion types."""

    energies: VaspData
    "Energy E at which the Dos is evaluated."
    dos: VaspData
    "Dos at the energies D(E)."
    projections: VaspData
    "Projection of the DOS onto contribution of specific atoms."
    stoichiometry: Stoichiometry
    "The atom types in the crystal."


@dataclasses.dataclass
class PhononMode:
    """The mode describes how the ions move under the presence of a phonon."""

    structure: Structure
    "The underlying structure in which the phonon mode is present."
    frequencies: VaspData
    "The phonon frequency of all the modes."
    eigenvectors: VaspData
    "The displacement patterns associated with the phonon modes."


@dataclasses.dataclass
class PiezoelectricTensor:
    """The piezoelectric tensor calculated in a linear response calculation.

    The piezoelectric tensor describes how an electric field induces a stress on the
    crystal. Equivalently, straining the system can induce a polarization. VASP splits
    the piezoelectric tensor into an electronic and an ionic contribution."""

    electron: VaspData
    "The electronic contribution to the piezoelectric tensor"
    ion: VaspData
    "The ionic contribution to the piezoelectric tensor"


@dataclasses.dataclass
class Polarization:
    """The electronic and ionic dipole moments.

    The polarization of a system results from the charge and the position of the ions.
    It is also the derivative of the total energy with respect to the electric field.
    VASP reports the dipole moments for ions and electrons, separately. For periodic
    systems polarizations are not well defined. Make sure to evaluate changes of the
    polarization relative to a centrosymmetric reference structure."""

    electron: VaspData
    "The electronic dipole moment resulting from the charge."
    ion: VaspData
    "The ionic dipole moment resulting from the position of the atoms."


@dataclasses.dataclass
class Potential:
    """The potential on a real space grid.

    Depending on the options set in the INCAR file, this dataclass can store the total
    potential, the hartree potential, the ionic potential and the exchange-correlation
    potential."""

    structure: VaspData
    """Atomic structure used to generate the potential"""
    hartree_potential: VaspData
    """Hartree potential, a contribution to the total potential"""
    ionic_potential: VaspData
    """Ionic potential, a contribution to the total potential"""
    xc_potential: VaspData
    """Exchange-correlation potential, a contribution to the total potential"""
    total_potential: VaspData
    """The total potential = ionic + hartree + xc potentials"""


@dataclasses.dataclass
class Projector:
    """Projectors used for atom and orbital projections.

    Set LORBIT to project quantities such as the DOS or the band structure onto atoms
    and orbitals. This class reports the atoms and orbitals included in the projection.
    """

    stoichiometry: Stoichiometry
    "The stoichiometry of the system used, i.e., which elements are contained."
    orbital_types: VaspData
    "Character indicating the orbital angular momentum."
    number_spin_projections: int
    "This is 1 for nonpolarized calculations, 2 for spin polarized ones, and 4 for noncollinear calculations."


@dataclasses.dataclass
class RunInfo:
    "Contains information about the VASP run."

    system: Optional[System] = None
    "Data of the system."
    runtime: Optional[RuntimeData] = None
    "Data about the runtime environment of the VASP calculation."
    structure: Optional[Structure] = None
    "Structural information about the system."
    contcar: Optional[CONTCAR] = None
    "The data corresponding to the CONTCAR file."
    phonon_dispersion: Optional[Dispersion] = None
    "The phonon dispersion of the system."


@dataclasses.dataclass
class RuntimeData:
    """Data about the runtime environment of the VASP calculation."""

    vasp_version: Union[str, Version] = None
    "The version of VASP used for the calculation."

    calculation_time: Optional[float] = None
    "The time taken for the calculation in seconds."
    calculation_start: Optional[Union[datetime, str]] = None
    "The date and time when the calculation was started."
    n_cpus: Optional[int] = None
    "The number of CPUs used for the calculation."
    n_gpus: Optional[int] = None
    "The number of GPUs used for the calculation."

    def __post_init__(self):
        if isinstance(self.vasp_version, Version):
            self.vasp_version = f"{self.vasp_version.major}.{self.vasp_version.minor}.{self.vasp_version.patch}"


@dataclasses.dataclass
class Stoichiometry:
    "Contains the type of ions in the system and how many of each type exist."

    number_ion_types: VaspData
    "Amount of ions of a particular type."
    ion_types: VaspData
    "Element of a particular type."


@dataclasses.dataclass
class Stress:
    "The stress acting on the unit cell at all steps."

    structure: Structure
    "Structural information about the system to inform about the unit cell."
    stress: VaspData
    "The values of the stress on the cell."


@dataclasses.dataclass
class Structure:
    """Structural information of the system.

    Reports what ions are in the system and the positions of all ions as well as the
    unit cell for all steps in a relaxation in a MD run."""

    stoichiometry: Stoichiometry
    "The stoichiometry of the system used, i.e., which elements are contained."
    cell: Cell
    "Unit cell of the crystal or simulation cell for molecules."
    positions: VaspData
    "Position of all atoms in the unit cell in units of the lattice vectors."


@dataclasses.dataclass
class System:
    "The name of the system set in the input."

    system: str


@dataclasses.dataclass
class Velocity:
    "Contains the ion velocities along the trajectory."

    structure: Structure
    "Structural information to relate the velocities to."
    velocities: VaspData
    "Observed ion velocities."


@dataclasses.dataclass
class Workfunction:
    "Describes the minimal energy needed to remove an electron from the crystal to the vacuum."

    idipol: int
    "INCAR tag of VASP describing the direction along which the potential is assessed."
    distance: VaspData
    "Distances along the lattice vector selected by IDIPOL"
    average_potential: VaspData
    "Averages the local potential after dipole correction in planes of the other two lattice vectors."
    vacuum_potential: VaspData
    "Potential in the vacuum region on either side of the surface."
    reference_potential: Bandgap
    "Describes the band edges in the surface."
    fermi_energy: float
    "Fermi energy obtained by VASP."
