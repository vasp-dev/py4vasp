# Copyright © VASP Software GmbH,
# Licensed under the Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
import numpy as np

from py4vasp import _config, exception
from py4vasp._calculation import base, slice_, structure
from py4vasp._third_party import view
from py4vasp._util import check, documentation, select

_index_note = """\
Notes
-----
The index order is different compared to the raw data when noncollinear calculations
are used. This routine returns the magnetic moments as (steps, orbitals, atoms,
directions)."""

_moment_selection = """\
selection : str
    If VASP was run with LORBMOM = T, the orbital moments are computed and the routine
    will default to the total moments. You can specify "spin" or "orbital" to select
    the individual contributions instead.
"""

_ORBITAL_PROJECTION = "orbital_projection"


@documentation.format(examples=slice_.examples("local_moment"))
class LocalMoment(slice_.Mixin, base.Refinery, structure.Mixin, view.Mixin):
    """The local moments describe the charge and magnetization near an atom.

    The projection on local moments is particularly relevant in the context of
    magnetic materials. It analyzes the electronic states in the vicinity of an
    atom by projecting the electronic orbitals onto the localized projectors of
    the PAWs. The local moments help understanding the magnetic ordering, the spin
    polarization, and the influence of neighboring atoms on the magnetic behavior.

    This class allows to access the computed moments from a VASP calculation.
    Remember that VASP calculates the projections only if you need to set
    :tag:`LORBIT` in the INCAR file. If the system is computed without spin
    polarization, the resulting moments correspond only to the local charges
    resolved by angular momentum. For collinear calculation, additionally the
    magnetic moment are computed. In noncollinear calculations, the magnetization
    becomes a vector. When comparing the results extracted from VASP to experimental
    observation, please be aware that the finite size of the radius in the projection
    may influence the observed moments. Hence, there is no one-to-one correspondence
    to the experimental moments.

    {examples}
    """

    _missing_data_message = "Atom resolved magnetic information not present, please verify LORBIT tag is set."

    length_moments = 1.5
    "Length in Å how a magnetic moment is displayed relative to the largest moment."

    @base.data_access
    def __str__(self):
        if self._is_nonpolarized:
            return "not spin polarized"
        magmom = "MAGMOM = "
        moments_last_step = self.magnetic("spin")
        moments_to_string = lambda vec: " ".join(f"{moment:.2f}" for moment in vec)
        if moments_last_step.ndim == 1:
            return magmom + moments_to_string(moments_last_step)
        else:
            separator = " \\\n         "
            generator = (moments_to_string(vec) for vec in moments_last_step)
            return magmom + separator.join(generator)

    @base.data_access
    @documentation.format(
        index_note=_index_note, examples=slice_.examples("local_moment", "to_dict")
    )
    def to_dict(self):
        """Read the charges and magnetization data into a dictionary.

        Returns
        -------
        dict
            Contains the charges and magnetic moments generated by VASP projected
            on atoms and orbitals.

        {index_note}

        {examples}
        """
        return {
            _ORBITAL_PROJECTION: self.selections()[_ORBITAL_PROJECTION],
            "charge": self.projected_charge(),
            **self._add_total_magnetic_moment(),
            **self._add_spin_and_orbital_moments(),
        }

    @base.data_access
    @documentation.format(
        selection=_moment_selection, examples=slice_.examples("local_moment", "to_view")
    )
    def to_view(self, selection="total", supercell=None):
        """Visualize the magnetic moments as arrows inside the structure.

        Parameters
        ----------
        {selection}

        Returns
        -------
        View
            Contains the atoms and the unit cell as well as an arrow indicating the
            strength of the magnetic moment. If noncollinear magnetism is used
            the moment points in the actual direction; for collinear magnetism
            the moments are aligned along the z axis by convention.

        {examples}
        """
        viewer = self._structure[self._steps].plot(supercell)
        if not self._is_nonpolarized:
            viewer.ion_arrows = list(
                self._prepare_magnetic_moments_for_plotting(selection)
            )
        return viewer

    @base.data_access
    @documentation.format(examples=slice_.examples("local_moment", "projected_charge"))
    def projected_charge(self):
        """Read the orbital- and site-projected charges of the selected steps.

        Returns
        -------
        np.ndarray
            Contains the charges for the selected steps projected on atoms and orbitals.

        {examples}
        """
        self._raise_error_if_steps_out_of_bounds()
        return self._raw_data.spin_moments[self._steps, 0]

    @base.data_access
    @documentation.format(
        selection=_moment_selection,
        index_note=_index_note,
        examples=slice_.examples("local_moment", "projected_magnetic"),
    )
    def projected_magnetic(self, selection="total"):
        """Read the orbital- and site-projected magnetic moments of the selected steps.

        Parameters
        ----------
        {selection}

        Returns
        -------
        np.ndarray
            Contains the magnetic moments for the selected steps projected on atoms and
            orbitals.

        {index_note}

        {examples}
        """
        self._raise_error_if_steps_out_of_bounds()
        self._raise_error_if_no_magnetic_moments()
        tree = select.Tree.from_selection(selection)
        moments = [self._magnetic_moments(selection) for selection in tree.selections()]
        return np.squeeze(moments)

    @base.data_access
    @documentation.format(examples=slice_.examples("local_moment", "charge"))
    def charge(self):
        """Read the site-projected charges of the selected steps.

        Returns
        -------
        np.ndarray
            Contains the charges for the selected steps projected on atoms. Equivalent
            to summing the projected charges over the orbitals.

        {examples}
        """
        return _sum_over_orbitals(self.projected_charge())

    @base.data_access
    @documentation.format(
        selection=_moment_selection,
        index_note=_index_note,
        examples=slice_.examples("local_moment", "magnetic"),
    )
    def magnetic(self, selection="total"):
        """Read the site-projected magnetic moments of the selected steps.

        Parameters
        ----------
        {selection}

        Returns
        -------
        np.ndarray
            Contains the magnetic moments for the selected steps projected on atoms.
            Equivalent to summing the projected magnetic moments over the orbitals.

        {index_note}

        {examples}
        """
        return _sum_over_orbitals(
            self.projected_magnetic(selection), is_vector=self._is_noncollinear
        )

    @base.data_access
    def selections(self):
        result = super().selections()
        if self._raw_data.spin_moments.shape[-1] == 4:
            result[_ORBITAL_PROJECTION] = ["s", "p", "d", "f"]
        else:
            result[_ORBITAL_PROJECTION] = ["s", "p", "d"]
        if self._is_nonpolarized:
            result["component"] = ["charge"]
        elif self._has_orbital_moments:
            result["component"] = ["charge", "total", "spin", "orbital"]
        else:
            result["component"] = ["charge", "total", "spin"]
        return result

    @property
    def _is_nonpolarized(self):
        return self._raw_data.spin_moments.shape[1] == 1

    @property
    def _is_collinear(self):
        return self._raw_data.spin_moments.shape[1] == 2

    @property
    def _is_noncollinear(self):
        return self._raw_data.spin_moments.shape[1] == 4

    @property
    def _has_orbital_moments(self):
        return not check.is_none(self._raw_data.orbital_moments)

    def _magnetic_moments(self, selection):
        self._raise_error_if_selection_not_available(selection)
        if self._is_collinear:
            return self._spin_moments()
        else:
            return self._noncollinear_moments(selection[0])

    def _noncollinear_moments(self, selection):
        spin_moments = self._spin_moments()
        orbital_moments = self._orbital_moments(spin_moments)
        if selection == "orbital":
            moments = orbital_moments
        elif selection == "spin":
            moments = spin_moments
        else:  # total
            moments = spin_moments + orbital_moments
        direction_axis = 1 if moments.ndim == 4 else 0
        return np.moveaxis(moments, direction_axis, -1)

    def _spin_moments(self):
        return self._raw_data.spin_moments[self._steps, 1:]

    def _orbital_moments(self, spin_moments):
        if not self._has_orbital_moments:
            return np.zeros_like(spin_moments)
        zero_s_moments = np.zeros((*spin_moments.shape[:-1], 1))
        orbital_moments = self._raw_data.orbital_moments[self._steps]
        return np.concatenate((zero_s_moments, orbital_moments), axis=-1)

    def _add_total_magnetic_moment(self):
        if self._is_nonpolarized:
            return {}
        return {"total": self.projected_magnetic()}

    def _add_spin_and_orbital_moments(self):
        if not self._has_orbital_moments:
            return {}
        spin_moments = self._spin_moments()
        orbital_moments = self._orbital_moments(spin_moments)
        direction_axis = 1 if spin_moments.ndim == 4 else 0
        return {
            "spin": np.moveaxis(spin_moments, direction_axis, -1),
            "orbital": np.moveaxis(orbital_moments, direction_axis, -1),
        }

    def _prepare_magnetic_moments_for_plotting(self, selection):
        tree = select.Tree.from_selection(selection)
        for (selection, *_) in tree.selections():
            moments = self.magnetic(selection)
            moments = self._make_sure_moments_have_timestep_dimension(moments)
            moments = _convert_moment_to_3d_vector(moments)
            max_length_moments = _max_length_moments(moments)
            if max_length_moments > 1e-15:
                rescale_moments = LocalMoment.length_moments / max_length_moments
                yield view.IonArrow(
                    quantity=rescale_moments * moments,
                    label=f"{selection} moments",
                    color=_color(selection),
                    radius=0.2,
                )

    def _make_sure_moments_have_timestep_dimension(self, moments):
        if not self._is_slice and moments is not None:
            moments = moments[np.newaxis]
        return moments

    def _raise_error_if_steps_out_of_bounds(self):
        try:
            np.zeros(self._raw_data.spin_moments.shape[0])[self._steps]
        except IndexError as error:
            raise exception.IncorrectUsage(
                f"Error reading the magnetic moments. Please check if the steps "
                f"`{self._steps}` are properly formatted and within the boundaries."
            ) from error

    def _raise_error_if_no_magnetic_moments(self):
        if self._is_nonpolarized:
            raise exception.NoData(
                "There are no magnetic moments in the data. Please make sure that you "
                "either set ISPIN = 2 or LNONCOLLINEAR = T or LSORBIT = T."
            )

    def _raise_error_if_selection_not_available(self, selection):
        if len(selection) != 1:
            raise exception.IncorrectUsage()
        selection = selection[0]
        if selection not in ("spin", "orbital", "total"):
            raise exception.IncorrectUsage(
                f"The selection {selection} is incorrect. Please check if it is spelled "
                "correctly. Possible choices are total, spin, or orbital."
            )
        if selection != "orbital" or self._has_orbital_moments:
            return
        raise exception.NoData(
            "There are no orbital moments in the VASP output. Please make sure that you "
            "run the calculation with LORBMOM = T and LSORBIT = T."
        )


def _sum_over_orbitals(quantity, is_vector=False):
    if quantity is None:
        return None
    if is_vector:
        return np.sum(quantity, axis=-2)
    return np.sum(quantity, axis=-1)


def _convert_moment_to_3d_vector(moments):
    if moments is not None and moments.ndim == 2:
        moments = moments.reshape((*moments.shape, 1))
        no_new_moments = (0, 0)
        add_zero_for_xy_axis = (2, 0)
        padding = (no_new_moments, no_new_moments, add_zero_for_xy_axis)
        moments = np.pad(moments, padding)
    return moments


def _max_length_moments(moments):
    if moments is not None:
        return np.max(np.linalg.norm(moments, axis=2))
    else:
        return 0.0


def _color(selection):
    if selection == "total":
        return _config.VASP_COLORS["blue"]
    if selection == "spin":
        return _config.VASP_COLORS["purple"]
    if selection == "orbital":
        return _config.VASP_COLORS["red"]
    raise exception.IncorrectUsage(f"Unknown component {selection} selected.")
